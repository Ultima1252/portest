#!/bin/sh
# Copyright (c) 2015, Ricky Gallamore
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those
# of the authors and should not be interpreted as representing official policies,
# either expressed or implied, of the FreeBSD Project.

PORTEST_VERSION="0.0.6"

usage() {
	cat << EOF
Usage: portest [-m git] [-f bulkfile] [-U default2] [-d PORTSDIR] [-abcdpPrRtTUv] \\
               file.diff file2.diff ...

Parameters:
    -a     --  Do everything except revert and port test (-ptf build.ports.txt)
    -c     --  Create repo, see -m for supported protocols
    -f     --  Generate a poudiere usable bulk file
    -p     --  Patch, will exit on fail with output
    -P     --  Patch, do not exit on failed patch
    -r     --  Revert the files listed in patchfile, fast
    -R     --  Revert modifications according tree, slow but will 
               guarantee tree integrity (git always uses this method)
    -t     --  Test with portlint
    -T     --  Test with port test, or poudriere depending on
               USE_POUDRIERE
    -u     --  Update repo
    -v     --  Show version of portest then exit
Options:
    -b     --  Generate the list of cat/ports based on port tree
               instead of diff, slow
    -d     --  Sets PORTSDIR, -U overrides this option
    -j     --  Jails used for poudriere, if multiple are used
               must be in "" with a space as a seperator,
               only used with -T option
    -m     --  Repo method, only used with -c valid methods are
               git,git+https,git+ssh,svn,svn+file,svn+http,
               svn+https,svn+ssh,portsnap  default method is git
    -U     --  Sets USE_POUDRIERE="YES" and sets port tree to use

By default, (no options) portest does nothing
EOF
	exit 1
}

ALL="0"
POUDRIERE_BULK="0"
DO_PATCH="0"
PATCH_FAILED_EXIT="0"
REVERT_SOFT="0"
REVERT_HARD="0"
TEST_PORTLINT="0"
TEST_BUILD="0"
REPO_BUILD_LIST="0"
CREATE_REPO="0"
UPDATE_REPO="0"

while getopts ":abcd:j:f:m:pPrRtTuU:v" FLAG; do
	case "${FLAG}" in
	a)
		ALL="1"
		;;
	b)
		REPO_BUILD_LIST="1"
		;;
	c)
		CREATE_REPO="1"
		;;
	d)
		PORTSDIR="${OPTARG}"
		;;
	j)
		POUDRIERE_JAILS="${OPTARG}"
		;;
	f)
		POUDRIERE_BULK="1"
		POUDRIERE_BULK_FILE="${OPTARG}"
		;;
	m)	
		METHOD="${OPTARG}"
		;;
	p)
		DO_PATCH="1"
		;;
	P)
		PATCH_FAILED_EXIT="1"
		;;
	r)
		REVERT_SOFT="1"
		;;
	R)
		REVERT_HARD="1"
		;;
	t)
		TEST_PORTLINT="1"
		;;
	T)
		TEST_BUILD="1"
		;;
	u)
		UPDATE_REPO="1"
		;;
	U)
		USE_POUDRIERE="YES"
		POUDRIERE_PORT="${OPTARG}"
		;;
	v)
		echo "${PORTEST_VERSION}"
		exit 0
	esac
done

[ $# -lt 1 ] && usage

shift "$((OPTIND-1))"

if [ ${REPO_BUILD_LIST} -ne 1 ]; then
[ $(( ALL + POUDRIERE_BULK + DO_PATCH + PATCH_FAILED_EXIT + REVERT_SOFT + TEST_PORTLINT + TEST_BUILD )) -ge 1 ] && [ $# -lt 1 ] && usage
elif [ $(( DO_PATCH + PATCH_FAILED_EXIT )) -ge 1 ] && [ $# -lt 1 ]; then
	usage;
fi

: ${METHOD:="git"}
if [ "${CREATE_REPO}" -eq "1" ] && [ "${USE_POUDRIERE}" != "YES" ]; then
	: ${GIT_URL:="github.com/freebsd/freebsd-ports"}
	: ${SVN_URL:="svn.FreeBSD.org/ports"}
	case ${METHOD} in
	git) PROTO="git" ;;
	git+https) PROTO="https" ;;
	git+ssh) PROTO="git" ;;
	svn) PROTO="svn" ;;
	svn+file) PROTO="file" ;;
	svn+http) PROTO="http" ;;
	svn+https) PROTO="https" ;;
	svn+ssh) PROTO="svn+ssh" ;;
	portsnap) ;;
	*) usage;;
	esac

	case ${METHOD} in
	git*) : ${BRANCH:="master"};;
	svn*) : ${BRANCH:="head"} ;;
	esac

	case ${METHOD} in
	git+ssh) GIT_REPO_URL="`echo ${PROTO}@${GIT_URL} | sed 's/\//\:&/'`" ;;
	git*) GIT_REPO_URL="${PROTO}://${GIT_URL}" ;;
	svn*) SVN_REPO_URL="${PROTO}://${SVN_URL}/${BRANCH}" ;;
	esac
fi

: ${PATCH:="patch"}
: ${PATCH_SVN_ARGS:="-Esf"}
: ${PATCH_GIT_ARGS:="-Esfp1"}
: ${PORTSNAP:="portsnap"}
: ${PORTSNAP_CREATE_ARGS:="fetch extract"}
: ${PORTSNAP_UPDATE_ARGS:="fetch update"}
: ${SVN:="svn"}
: ${SVN_CHECKOUT_ARGS:="checkout ${SVN_REPO_URL}"}
: ${SVN_REVERT_ARGS:="revert -R"}
: ${SVN_STATUS_ARGS:="status"}
: ${SVN_UPDATE_ARGS:="update"}
: ${GIT:="git"}
: ${GIT_CLEAN_ARGS:="clean -Xfd -f"}
: ${GIT_CLONE_ARGS:="clone --depth 1 -b ${BRANCH} ${GIT_REPO_URL}"}
: ${GIT_RESET_ARGS:="reset --hard"}
: ${GIT_STATUS_ARGS:="status -s"}
: ${GIT_UPDATE_ARGS:="pull"}
: ${GIT_STASH_ARGS:="stash"}
: ${GIT_STASHPOP_ARGS:="stash pop"}
: ${RM:="rm"}
: ${RM_ARGS:="-rf"}
: ${PORTLINT:="portlint"}
: ${PORTLINT_ARGS:="-A"}
: ${PORT:="port"}
: ${PORT_ARGS:="test"}
: ${PORTSDIR:="/usr/ports"}
: ${BULK_FILE:="build.ports.txt"}


: ${USE_POUDRIERE:="NO"}
: ${POUDRIERE_JAILS:=""}
: ${POUDRIERE_PORTSDIR:="/usr/local/poudriere/ports"}
: ${POUDRIERE_PORT:="default"}
: ${POUDRIERE:="poudriere"}
: ${POUDRIERE_ARGS:="bulk -t -C -p ${POUDRIERE_PORT}"}
: ${POUDRIERE_PORTS_ARGS:="ports -c -m ${METHOD} -p ${POUDRIERE_PORT} fetch extract"}

# Set poudriere ports dir if being used #
if [ "${USE_POUDRIERE}" == "YES" ]; then
PORTSDIR="${POUDRIERE_PORTSDIR}/${POUDRIERE_PORT}"
fi

CURDIR="`pwd`"

# Check for commands #
${SVN} help >/dev/null 2>&1
if [ "$?" -ne "0" ]; then
	svnlite help >/dev/null 2>&1
	if [ "$?" -eq "0" ]; then
		SVN="svnlite"
	else
		SVN_CHECK="NO"
	fi
fi
${GIT} help >/dev/null 2>&1
if [ "$?" -ne "0" ]; then
	GIT_CHECK="NO"
fi
${PORTSNAP} >/dev/null 2>&1
if [ "$?" -ne "0" ]; then
	PORTSNAP_CHECK="NO"
fi

check_git() {
if [ "${GIT_CHECK}" == "NO" ]; then
echo "git not found. Try installing it, pkg install git" && exit 1
fi
}

check_svn() {
if [ "${SVN_CHECK}" == "NO" ]; then
echo "svn or svnlite not found. Try installing it, pkg install subversion" && exit 1
fi
}

check_empty_dir() {
	mkdir -p "$1"
	[ ! "`find \"$1\" -type d -empty -maxdepth 1`" ] && echo ${PORTSDIR} is not empty && exit 1
}
### Create Repo ###
if [ "${CREATE_REPO}" -eq "1" ]; then
	if [ "${USE_POUDRIERE}" == "YES" ]; then
		${POUDRIERE} ${POUDRIERE_PORTS_ARGS}
	else
		case ${METHOD} in
			git*)
			check_git;
			check_empty_dir "${PORTSDIR}";
			${GIT} ${GIT_CLONE_ARGS} "${PORTSDIR}"
			if [ "$?" -ne "0" ]; then
			echo "git clone failed" && exit 1
			fi
			;;
			svn*)
			check_svn;
			check_empty_dir "${PORTSDIR}";
			${SVN} ${SVN_CHECKOUT_ARGS} "${PORTSDIR}"
			if [ "$?" -ne "0" ]; then
			echo "svn checkout failed" && exit 1
			fi
			;;
			portsnap)
			check_empty_dir "${PORTSDIR}";
			cd ${PORTSDIR} && PORTSDIR="`pwd`"
			if [ "${PORTSDIR}" != "/usr/ports" ]; then
				mkdir : ${PORTSNAP_WRKDIR:="${PORTSDIR}/.snap"}
				${PORTSNAP} -d "${PORTSNAP_WRKDIR}" -p "${PORTSDIR}" ${PORTSNAP_CREATE_ARGS}
			else
				${PORTSNAP} ${PORTSNAP_CREATE_ARGS}
			fi
			if [ "$?" -ne "0" ]; then
			echo "portsnap creation failed" && exit 1
			fi
			;;
		esac
	fi
fi
# Check PORTSDIR #
! [ -d "${PORTSDIR}" ] && echo "PORTSDIR not set or incorrect directory" && exit 1
cd ${PORTSDIR} && PORTSDIR="`pwd`"

if [ "FreeBSD Ports Collection" != "`head -1 "${PORTSDIR}/README" | grep -o \"FreeBSD Ports Collection\"`" ]; then
	echo "PORTSDIR is set to an incorrect directory"
	exit 1
fi
# Check PORTSDIR is an svn or git tree #
cd ${PORTSDIR}
if [ "${SVN_CHECK}" != "NO" ]; then
	${SVN} info >/dev/null 2>&1
	if [ "$?" -eq "0" ]; then
		REPO_TYPE="svn"
		REPO="${SVN}"
		REPO_STATUS="${SVN_STATUS_ARGS}"
	fi
fi
if [ "${GIT_CHECK}" != "NO" ]; then
	${GIT} branch >/dev/null 2>&1
	if [ "$?" -eq "0" ]; then
		REPO_TYPE="git"
		REPO="${GIT}"
		REPO_STATUS="${GIT_STATUS_ARGS}"
	fi
fi
if [ -z "${REPO_TYPE}" ] && [ "${PORTSNAP_CHECK}" != "NO" ]; then
	if [ "${PORTSDIR}" != "/usr/ports" ]; then
		: ${PORTSNAP_WRKDIR:="${PORTSDIR}/.snap"}
		: ${PORTSNAP_ARGS:="-d ${PORTSNAP_WRKDIR} -p ${PORTSDIR}"}
	else
		: ${PORTSNAP_WRKDIR:=""}
		: ${PORTSNAP_ARGS:=""}
	fi
	REPO_TYPE="portsnap"
	! [ -d "${PORTSNAP_WRKDIR}" ] && echo "Unsupported repo or portsnap wrkdir not found. Set PORTSNAP_WRKDIR if the latter"
fi

if [ "${REPO_BUILD_LIST}" -eq "1" ]; then
	case ${REPO_TYPE} in
	svn*);;
	git*);;
	*) echo "Port tree is not a svn or git repo, This is required with the -b option" && exit 1 ;;
	esac
fi

# Set patchfile path #
cd "${PORTSDIR}"
for file in "${@}"; do
	if [ -f "$file" ]; then
		PATCH_FILE="${PATCH_FILE} $file"
	elif [ -f "${CURDIR}/$file" ]; then
		PATCH_FILE="${PATCH_FILE} ${CURDIR}/$file"
	else
		echo "$file not found"
		exit 1
	fi
done

for file in ${PATCH_FILE}; do
	if [ "Index:" == "`head -4 \"$file\" | grep -m 1 -o \"^Index:\"`" ]; then
		SVN_PATCH_FILE="${SVN_PATCH_FILE} $file"
	elif [ "diff --git" == "`head -4 \"$file\" | grep -m 1 -o \"^diff \-\-git\"`" ]; then
		GIT_PATCH_FILE="${GIT_PATCH_FILE} $file"
	else
		echo "$file is not a svn or git patchfile"
		exit 1
	fi
done

# Check for valid jails #
if [ "${USE_POUDRIERE}" == "YES" ] && [ "${TEST_BUILD}" -eq "1" ]; then
	[ -z "${POUDRIERE_JAILS}" ] && echo "no jails selected use -j or export POUDRIERE_JAILS=\"jail1 jail2\""
	for jail in ${POUDRIERE_JAILS}; do
	${POUDRIERE} jail -i -j $jail >/dev/null 2>&1
	[ $? -ne 0 ] && echo "No such jail $jail" && exit 1
	done
fi

### Update Repo ###
if [ "${UPDATE_REPO}" -eq "1" ]; then
cd ${PORTSDIR}
	case ${REPO_TYPE} in
		svn)
			${SVN} ${SVN_UPDATE_ARGS}
		;;
		git)
			${GIT} ${GIT_STASH_ARGS}
			${GIT} ${GIT_UPDATE_ARGS}
			${GIT} ${GIT_STASHPOP_ARGS}
		;;
		portsnap)
			${PORTSNAP} ${PORTSNAP_ARGS} ${PORTSNAP_UPDATE_ARGS}
	esac
fi

### Patch Tree ###
if [ "${DO_PATCH}" -eq "1" ] || [ "${PATCH_FAILED_EXIT}" -eq "1" ] || [ "${ALL}" -eq "1" ]; then
	for file in ${SVN_PATCH_FILE}; do
	PATCH_OUTPUT="${PATCH_OUTPUT}
"`${PATCH} ${PATCH_SVN_ARGS} -d "${PORTSDIR}" -i "$file"`
	done
	for file in ${GIT_PATCH_FILE}; do
	PATCH_OUTPUT="${PATCH_OUTPUT}
"`${PATCH} ${PATCH_GIT_ARGS} -d "${PORTSDIR}" -i "$file"`
	done
		for file in `echo "${PATCH_OUTPUT}" | awk '{print $(NF)}'`; do
			echo "$file"
			cat "${PORTSDIR}/$file"
		done
		
	if [ "`echo "${PATCH_OUTPUT}" | grep -m 1 -o rejects`" == "rejects" ] && [ "${PATCH_FAILED_EXIT}" -ne "1" ]; then
		echo "${PATCH_OUTPUT}"
		echo "Patch Failed"
		exit 1
	else
		if [ "svn" == "${REPO_TYPE}" ]; then
			${RM} `${SVN} ${SVN_STATUS_ARGS} | awk '{ print $2 }' | grep ".*\.orig"` >/dev/null
		elif [ "git" == "${REPO_TYPE}" ]; then
			${GIT} ${GIT_CLEAN_ARGS} >/dev/null
		fi
	fi
fi

# Generate a list of ports for poudriere to build #
buildlist() {

if [ "${REPO_BUILD_LIST}" -eq "1" ]; then
cd ${PORTSDIR}
BUILD_LIST="`(${REPO} ${REPO_STATUS} | awk '{ print $2 }' | sed 's/^[MTK].*//' | grep -o '^.*\/.*\/' | sed 's/^.*\/.*\/files\/$// ; s/\/$//' | sort | awk '!a[$0]++')`"
else
[ -n "${SVN_PATCH_FILE}" ] && BUILD_LIST="`(cat ${SVN_PATCH_FILE} | grep '^Index:[ ].*' | sed 's/^Index: // ; s/^[MTK].*//' | grep -o '^.*\/.*\/' | sed 's/^.*\/.*\/files\/$// ; s/\/$//')`"
[ -n "${GIT_PATCH_FILE}" ] && BUILD_LIST="${BUILD_LIST}
"`cat ${GIT_PATCH_FILE} | grep "^diff \-\-git" | awk '{print $(NF)}' | sed 's/^b\/// ; s/^[MTK].*//' | grep -o '^.*\/.*\/' | sed 's/^.*\/.*\/files\/$// ; s/\/$//'`
BUILD_LIST="`echo "${BUILD_LIST}" | sort | awk '!a[$0]++'`"
fi
}

### Bulk File ###
if [ "$POUDRIERE_BULK" -eq "1" ]; then
	[ -z "${BUILD_LIST}" ] && buildlist
	cd "${CURDIR}"
	echo "${BUILD_LIST}" >"${POUDRIERE_BULK_FILE}"
elif [ "${ALL}" -eq "1" ]; then
	[ -z "${BUILD_LIST}" ] && buildlist
	cd "${CURDIR}"
	echo "${BUILD_LIST}" >"${BULK_FILE}"
fi

### Portlint ###
if [ "${TEST_PORTLINT}" -eq "1" ] || [ "${ALL}" -eq "1" ]; then
	[ -z "${BUILD_LIST}" ] && buildlist
	for port in ${BUILD_LIST}; do
		cd "${PORTSDIR}/$port"
		echo "$port"
		${PORTLINT} ${PORTLINT_ARGS}
	done
fi


### Port test and Poudriere testing ###
if [ "${TEST_BUILD}" -eq "1" ] && [ "${USE_POUDRIERE}" != "YES" ]; then
	${RM} ${RM_ARGS} "`find ${PORTSDIR} -type directory -name "work" -maxdepth 3`"
	[ -z "${BUILD_LIST}" ] && buildlist
	for port in ${BUILD_LIST}; do
		cd "${PORTSDIR}/$port"
		make depends BATCH=yes
		${PORT} ${PORT_ARGS}
	done
elif [ "${TEST_BUILD}" -eq "1" ] && [ "${USE_POUDRIERE}" == "YES" ]; then
	[ -z "${BUILD_LIST}" ] && buildlist
	for jail in ${POUDRIERE_JAILS}; do
		${POUDRIERE} ${POUDRIERE_ARGS} -j $jail ${BUILD_LIST}
	done
fi

### Revert Patch ###
cd ${PORTSDIR}
case ${REPO_TYPE} in
	svn)
if [ "${REVERT_SOFT}" -eq "1" ] && [ "${REVERT_HARD}" -ne "1" ]; then
	[ -z "${BUILD_LIST}" ] && buildlist
# Generate a list of files that were patched #
	[ -n "${SVN_PATCH_FILE}" ] && PATCH_FILES_LIST="`cat ${SVN_PATCH_FILE} | grep '^Index:[ ].*' | awk '{ print $2 }'`"
	[ -n "${GIT_PATCH_FILE}" ] && PATCH_FILES_LIST="${PATCH_FILES_LIST}
"`cat ${GIT_PATCH_FILE} | grep "^diff \-\-git" | awk '{print $(NF)}' | sed 's/^b\///'`
# Wierd cases where svn won't see short filenames in list.    #
# This seems to be an svn bug, this list helps in those cases #
	PATCH_FILES_FILTERED="`echo "${PATCH_FILES_LIST}" | grep -v '^[a-z].*\/.*\/.*'`"
	for file in ${BUILD_LIST}; do
		${RM} ${RM_ARGS} "${PORTSDIR}/$file"
	done
	for file in ${PATCH_FILES_LIST}; do
		${RM} ${RM_ARGS} "${PORTSDIR}/$file"
	done
	[ -n "${BUILD_LIST}" ] && ${SVN} ${SVN_REVERT_ARGS} ${BUILD_LIST}
	[ -n "${PATCH_FILES_LIST}" ] && ${SVN} ${SVN_REVERT_ARGS} ${PATCH_FILES_LIST}
	[ -n "${PATCH_FILES_FILTERED}" ] && ${SVN} ${SVN_REVERT_ARGS} ${PATCH_FILES_FILTERED}
elif [ "${REVERT_HARD}"  -eq "1" ]; then
	for file in `${SVN} status | awk '{ print $2 }'`; do
		${RM} ${RM_ARGS} "${PORTSDIR}/$file"
	done
	${SVN} ${SVN_REVERT_ARGS} ${PORTSDIR}
fi
	;;
	git)
if [ "${REVERT_SOFT}" -eq "1" ] || [ "${REVERT_HARD}" -eq "1" ]; then
	${GIT} ${GIT_CLEAN_ARGS}
	${GIT} ${GIT_RESET_ARGS}
fi
	;;
esac
