#!/bin/sh
# Copyright (c) 2015, Ricky Gallamore
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those
# of the authors and should not be interpreted as representing official policies,
# either expressed or implied, of the FreeBSD Project.

PORTEST_VERSION="0.1.2"

usage() {
	cat << EOF
Usage: portest [-m git] [-f bulkfile] [-U default2] [-d PORTSDIR] [-abcCdprRtTuv] \\
               file.diff file2.diff ...

Parameters:
    -a     --  Do everything except revert and port test (-ptf build.ports.txt)
    -c     --  Create repo, see -m for supported protocols, default is git
    -f     --  Generate a poudiere usable bulk file
    -p     --  Patch, will exit on fail with output
               portsnap will create a backup directory
               which is used on soft reverts (-r) and updates (-u)
    -r     --  Soft Revert, quick and effective
               portsnap uses backup created when patch (-p) is used, fast
               git (-r) is same as (-R) see below
               svn reverts all files from input patchfiles, fast
    -R     --  Hard Revert, portsnap will rebuild tree, very slow
               git does hard reset and cleans all files, fast
               svn removed all files via status and revert -R, very slow!!
    -t     --  Test with portlint
    -T     --  Test with port test, or poudriere depending on
               USE_POUDRIERE
    -u     --  Update repo, git and svn will do a hard revert (-R) first
               portsnap do a soft revert if a backup directory exists
    -v     --  Show version of portest then exit
Options:
    -b     --  Generate the list of cat/ports based on port tree
               instead of diff, git and svn only, slow
    -C     --  Check, Will still make backups and files required
               to apply patches but will not apply them
    -d     --  Sets PORTSDIR, -U overrides this option
    -j     --  Jails used for poudriere, if multiple are used
               must be in "" with a space as a seperator,
               only used with -T option
    -m     --  Repo method, only used with -c valid methods are
               git,git+https,git+ssh,svn,svn+file,svn+http,
               svn+https,svn+ssh,portsnap  default method is git
    -U     --  Sets USE_POUDRIERE="YES" and sets port tree to use

By default, (no options) portest does nothing
EOF
	exit 1
}

ALL="0"
POUDRIERE_BULK="0"
DO_PATCH="0"
REVERT_SOFT="0"
REVERT_HARD="0"
TEST_PORTLINT="0"
TEST_BUILD="0"
REPO_BUILD_LIST="0"
CREATE_REPO="0"
UPDATE_REPO="0"
CHECK_ONLY=0

while getopts ":abcCd:j:f:m:prRtTuU:v" FLAG; do
	case "${FLAG}" in
	a)
		ALL="1"
		;;
	b)
		REPO_BUILD_LIST="1"
		;;
	c)
		CREATE_REPO="1"
		;;
	C)
		CHECK_ONLY="1"
		;;
	d)
		PORTSDIR="${OPTARG}"
		;;
	j)
		POUDRIERE_JAILS="${OPTARG}"
		;;
	f)
		POUDRIERE_BULK="1"
		POUDRIERE_BULK_FILE="${OPTARG}"
		;;
	m)	
		METHOD="${OPTARG}"
		;;
	p)
		DO_PATCH="1"
		;;
	r)
		REVERT_SOFT="1"
		;;
	R)
		REVERT_HARD="1"
		;;
	t)
		TEST_PORTLINT="1"
		;;
	T)
		TEST_BUILD="1"
		;;
	u)
		UPDATE_REPO="1"
		;;
	U)
		USE_POUDRIERE="YES"
		POUDRIERE_PORT="${OPTARG}"
		;;
	v)
		echo "${PORTEST_VERSION}"
		exit 0
		;;
	*)
		usage
		exit 1
		;;
	esac
done

[ $# -lt 1 ] && usage

shift "$((OPTIND-1))"

if [ ${REPO_BUILD_LIST} -ne 1 ]; then
[ $(( ALL + POUDRIERE_BULK + DO_PATCH + REVERT_SOFT + TEST_PORTLINT + TEST_BUILD )) -ge 1 ] && [ $# -lt 1 ] && usage
elif [ $(( DO_PATCH )) -ge 1 ] && [ $# -lt 1 ]; then
	usage;
fi

: ${METHOD:="git"}
if [ "${CREATE_REPO}" -eq "1" ] && [ "${USE_POUDRIERE}" != "YES" ]; then
	: ${GIT_URL:="github.com/freebsd/freebsd-ports"}
	: ${SVN_URL:="svn.FreeBSD.org/ports"}
	case ${METHOD} in
	git) PROTO="git" ;;
	git+https) PROTO="https" ;;
	git+ssh) PROTO="git" ;;
	svn) PROTO="svn" ;;
	svn+file) PROTO="file" ;;
	svn+http) PROTO="http" ;;
	svn+https) PROTO="https" ;;
	svn+ssh) PROTO="svn+ssh" ;;
	portsnap) ;;
	*) usage;;
	esac

	case ${METHOD} in
	git*) : ${BRANCH:="master"} ;;
	svn*) : ${BRANCH:="head"} ;;
	esac

	case ${METHOD} in
	git+ssh) GIT_REPO_URL="`echo ${PROTO}@${GIT_URL} | sed 's/\//\:&/'`" ;;
	git*) GIT_REPO_URL="${PROTO}://${GIT_URL}" ;;
	svn*) SVN_REPO_URL="${PROTO}://${SVN_URL}/${BRANCH}" ;;
	esac
fi

: ${PATCH:="/usr/bin/patch"}
: ${PATCH_ARGS:="-Ef"}
: ${PORTSNAP:="/usr/sbin/portsnap"}
: ${PORTSNAP_FETCH_ARGS:="fetch"}
: ${PORTSNAP_EXTRACT_ARGS:="extract"}
: ${PORTSNAP_UPDATE_ARGS:="update"}
: ${SVN:="/usr/local/bin/svn"}
: ${SVN_CHECKOUT_ARGS:="checkout ${SVN_REPO_URL}"}
: ${SVN_PATCH_ARGS:="patch"}
: ${SVN_REVERT_ARGS:="revert -R"}
: ${SVN_STATUS_ARGS:="status"}
: ${SVN_UPDATE_ARGS:="update"}
: ${GIT:="/usr/local/bin/git"}
: ${GIT_ADD_ARGS:="add -AN"}
: ${GIT_CLEAN_ARGS:="clean -fd -f"}
: ${GIT_CLONE_ARGS:="clone --depth 1 -b ${BRANCH} ${GIT_REPO_URL}"}
: ${GIT_APPLY_ARGS:="apply --whitespace=nowarn"}
: ${GIT_RESET_ARGS:="reset --hard"}
: ${GIT_STATUS_ARGS:="status -s"}
: ${GIT_UPDATE_ARGS:="pull"}
: ${MAKE:="/usr/bin/make"}
: ${OPENSSL:="/usr/bin/openssl"}
: ${TMUX_COMMAND:="/usr/local/bin/tmux"}
: ${TMUX_LAYOUT:="tiled"}
: ${AWK:="/usr/bin/awk"}
: ${CAT:="/bin/cat"}
: ${RM:="/bin/rm"}
: ${RMDIR:="/bin/rmdir"}
: ${FIND:="/usr/bin/find"}
: ${GREP:="/usr/bin/grep"}
: ${HEAD:="/usr/bin/head"}
: ${MKDIR:="/bin/mkdir"}
: ${MV:="/bin/mv"}
: ${SED:="/usr/bin/sed"}
: ${SLEEP:="/bin/sleep"}
: ${SORT:="/usr/bin/sort"}
: ${TOUCH:="/usr/bin/touch"}
: ${PORTLINT:="/usr/local/bin/portlint"}
: ${PORTLINT_ARGS:="-AC"}
: ${PORT:="/usr/local/bin/port"}
: ${PORT_ARGS:="test"}
: ${PORTSDIR:="/usr/ports"}
: ${BULK_FILE:="build.ports.txt"}


: ${USE_POUDRIERE:="NO"}
: ${POUDRIERE_JAILS:=""}
: ${POUDRIERE_PORTSDIR:="/usr/local/poudriere/ports"}
: ${POUDRIERE_PORT:="default"}
: ${POUDRIERE:="/usr/local/bin/poudriere"}
: ${POUDRIERE_STATUS_ARGS:="status -cH"}
: ${POUDRIERE_BULK_ARGS:="bulk -t -C -p ${POUDRIERE_PORT}"}
: ${POUDRIERE_PORTS_ARGS:="ports -c -m ${METHOD} -p ${POUDRIERE_PORT}"}

# Set poudriere ports dir if being used #
if [ "${USE_POUDRIERE}" == "YES" ]; then
PORTSDIR="${POUDRIERE_PORTSDIR}/${POUDRIERE_PORT}"
fi

CURDIR="`pwd`"

# Check commands #
check_git() {
if ! [ -x "${GIT}" ]; then
	GIT="`command -v git`"
	if ! [ -x "${GIT}" ]; then
		echo "git not found. Try installing it, pkg install git" && exit 1
	fi
fi
}

check_svn() {
if ! [ -x "${SVN}" ]; then
	SVN="`command -v svn`"
	if ! [ -x "${SVN}" ]; then
		SVN="`command -v svnlite`"
		if ! [ -x "${SVN}" ]; then
			echo "svn or svnlite not found. Try installing it, pkg install subversion" && exit 1
		fi
	fi
fi
}

check_port() {
if ! [ -x "${PORT}" ]; then
	PORT="`command -v port`"
	if ! [ -x "${PORT}" ]; then
		echo "port not found. Try installing it, pkg install porttools" && exit 1
	fi
fi
}

check_portlint() {
if ! [ -x "${PORTLINT}" ]; then
	PORTLINT="`command -v portlint`"
	if ! [ -x "${PORTLINT}" ]; then
		echo "portlint not found. Try installing it, pkg install portlint" && exit 1
	fi
fi
}

check_poudriere() {
if ! [ -x "${POUDRIERE}" ]; then
	POUDRIERE="`command -v poudriere`"
	if ! [ -x "${POUDRIERE}" ]; then
	echo "poudriere not found. Try installing it, pkg install poudriere" && exit 1
	fi
fi
}

check_tmux() {
if ! [ -x "${TMUX_COMMAND}" ]; then
	TMUX_COMMAND="`command -v tmux`"
	if ! [ -x "${TMUX_COMMAND}" ]; then
	echo "tmux not found. Try installing it, pkg install tmux" && exit 1
	fi
fi
}

check_openssl() {
if ! [ -x "${OPENSSL}" ]; then
	OPENSSL="`command -v openssl`"
	if ! [ -x "${OPENSSL}" ]; then
	echo "openssl not found. Try installing it, pkg install openssl" && exit 1
	fi
fi
}

check_make() {
if ! [ -x "${MAKE}" ]; then
	MAKE="`command -v make`"
	if ! [ -x "${MAKE}" ]; then
	echo "make not found" && exit 1
	fi
fi
}

check_command() {
if ! [ -x "$1" ]; then
	echo "$1 not found" && exit 1
fi
}

check_empty_dir() {
	${MKDIR} -p "$1"
	[ ! "`${FIND} "$1" -type d -empty -maxdepth 1`" ] && echo "$1 is not empty" && exit 1
}
### Create Repo ###
if [ "${CREATE_REPO}" -eq "1" ]; then
	if [ "${USE_POUDRIERE}" == "YES" ]; then
		check_poudriere
		${POUDRIERE} ${POUDRIERE_PORTS_ARGS}
	else
		case ${METHOD} in
			git*)
			check_git
			check_empty_dir "${PORTSDIR}"
			${GIT} ${GIT_CLONE_ARGS} "${PORTSDIR}"
			if [ "$?" -ne "0" ]; then
			echo "git clone failed" && exit 1
			fi
			;;
			svn*)
			check_svn
			check_empty_dir "${PORTSDIR}"
			${SVN} ${SVN_CHECKOUT_ARGS} "${PORTSDIR}"
			if [ "$?" -ne "0" ]; then
			echo "svn checkout failed" && exit 1
			fi
			;;
			portsnap*)
			check_command "${PORTSNAP}"
			check_empty_dir "${PORTSDIR}"
			cd ${PORTSDIR} && PORTSDIR="`pwd`"
			if [ "${PORTSDIR}" != "/usr/ports" ]; then
				${MKDIR} : ${PORTSNAP_WRKDIR:="${PORTSDIR}/.snap"}
				${PORTSNAP} -d "${PORTSNAP_WRKDIR}" -p "${PORTSDIR}" ${PORTSNAP_FETCH_ARGS} ${PORTSNAP_EXTRACT_ARGS}
			else
				${PORTSNAP} ${PORTSNAP_FETCH_ARGS} ${PORTSNAP_EXTRACT_ARGS}
			fi
			if [ "$?" -ne "0" ]; then
			echo "portsnap creation failed" && exit 1
			fi
			;;
		esac
	fi
fi
# Check PORTSDIR #
! [ -d "${PORTSDIR}" ] && echo "PORTSDIR not set or incorrect directory" && exit 1
cd ${PORTSDIR} && PORTSDIR="`pwd`"
: ${BACKUPDIR:="${PORTSDIR}/.bak"}

[ "`${HEAD} -1 "${PORTSDIR}/README" | ${GREP} -com1 \"FreeBSD Ports Collection\"`" -ne "1" ] && echo "PORTSDIR is set to an incorrect directory" && exit 1

# Check PORTSDIR is an svn or git tree #
[ -d "${PORTSDIR}/.svn" ] && check_svn && REPO_TYPE="svn" REPO="${SVN}" REPO_STATUS="${SVN_STATUS_ARGS}"

[ -d "${PORTSDIR}/.git" ] && check_git && REPO_TYPE="git" REPO="${GIT}" REPO_STATUS="${GIT_STATUS_ARGS}"

if [ -z "${REPO_TYPE}" ]; then
	check_command "${PORTSNAP}"
	if [ "${PORTSDIR}" != "/usr/ports" ]; then
		: ${PORTSNAP_WRKDIR:="${PORTSDIR}/.snap"}
		: ${PORTSNAP_ARGS:="-d ${PORTSNAP_WRKDIR} -p ${PORTSDIR}"}
	! [ -d "${PORTSNAP_WRKDIR}" ] && echo "Unsupported repo or portsnap wrkdir not found. Set PORTSNAP_WRKDIR if the latter" && exit 1
	else
		: ${PORTSNAP_WRKDIR:=""}
		: ${PORTSNAP_ARGS:=""}
	fi
	REPO_TYPE="portsnap"
fi
if [ "${CHECK_ONLY}" -eq "1" ]; then
	case ${REPO_TYPE} in
		svn*) SVN_CHECK_ARGS="--dry-run" ;;
		git*) GIT_CHECK_ARGS="--check" ;;
		portsnap*) PATCH_CHECK_ARGS="-C" ;;
	esac
fi

if [ "${REPO_BUILD_LIST}" -eq "1" ]; then
	case ${REPO_TYPE} in
	svn*);;
	git*);;
	*) echo "Port tree is not a svn or git repo, This is required with the -b option" && exit 1 ;;
	esac
fi

# Set patchfile path #
cd "${PORTSDIR}"
for file in "${@}"; do
	if [ -f "$file" ]; then
		PATCH_FILE="${PATCH_FILE}
$file"
	elif [ -f "${CURDIR}/$file" ]; then
		PATCH_FILE="${PATCH_FILE}
${CURDIR}/$file"
	else
		echo "$file not found"
		exit 1
	fi
done

for file in ${PATCH_FILE}; do
	if [ "`${CAT} "$file" | ${GREP} -com1 '^+++[ ].*'`" -eq "1" ]; then
		UNI_PATCH_FILE="${UNI_PATCH_FILE}
$file"
	else
		echo "$file is not a recognized patch format"
		exit 1
	fi
done

# Check for valid jails #
if [ "${USE_POUDRIERE}" == "YES" ] && [ "${TEST_BUILD}" -eq "1" ]; then
	check_poudriere
	[ -z "${POUDRIERE_JAILS}" ] && echo "no jails selected use -j or export POUDRIERE_JAILS=\"jail1 jail2\"" && exit 1
	POUDRIERE_JAILS=`printf "%s\n" ${POUDRIERE_JAILS} | ${SORT} -u`
	for jail in ${POUDRIERE_JAILS}; do
	${POUDRIERE} jail -i -j $jail >/dev/null 2>&1
	[ $? -ne 0 ] && echo "No such jail $jail" && exit 1
	done
fi

git_revert() {
${GIT} ${GIT_RESET_ARGS}
${GIT} ${GIT_CLEAN_ARGS} -X
${GIT} ${GIT_CLEAN_ARGS}
}

portsnap_soft_revert() {
cd ${BACKUPDIR}
for dir in `${FIND} ./ -type d -maxdepth 1 | ${SED} 's/^\.\///' | ${GREP} '^[A-Z]'`; do
	${RM} -rf "${PORTSDIR}/$dir"
	${MV} "${BACKUPDIR}/$dir" "${PORTSDIR}/$dir"
done
EMPTY_FOLDERS="`${FIND} ./ -type d -mindepth 2 -maxdepth 3 -empty | ${SED} 's/^\.\///'`"
for dir in `${FIND} ./ -type d -mindepth 2 -maxdepth 2 | ${SED} 's/^\.\///'`; do
	${RM} -rf "${PORTSDIR}/$dir"
	[ -n "${EMPTY_FOLDERS}" ] && ${RMDIR} -p `echo "${EMPTY_FOLDERS}"` >/dev/null 2>&1
	[ -n "${EMPTY_FOLDERS}" ] && unset EMPTY_FOLDERS
	[ -d "${BACKUPDIR}/$dir" ] && ${MV} "${BACKUPDIR}/$dir" "${PORTSDIR}/$dir"
done
for file in `${FIND} ./ -type f -maxdepth 2 | ${SED} 's/^\.\///'`; do
	${RM} -f "${PORTSDIR}/$file"
	${MV} "${BACKUPDIR}/$file" "${PORTSDIR}/$file"
done
cd ${PORTSDIR}
${RM} -r "${BACKUPDIR}"
${RM} `${FIND} ./ -maxdepth 2 -name "*.[ro][er][ji]*"` >/dev/null 2>&1
}

svn_hard_revert() {
cd ${PORTSDIR}
for file in `${SVN} status | ${AWK} '{ print $(NF) }'`; do
	${RM} -rf "${PORTSDIR}/$file"
done
${SVN} ${SVN_REVERT_ARGS} ${PORTSDIR}
${RM} `${FIND} ./ -maxdepth 1 -name "*.[ro][er][ji]*"` >/dev/null 2>&1
}

### Update Repo ###
if [ "${UPDATE_REPO}" -eq "1" ]; then
cd ${PORTSDIR}
	case ${REPO_TYPE} in
		svn)
			svn_hard_revert
			${SVN} ${SVN_UPDATE_ARGS}
		;;
		git)
			git_revert
			${GIT} ${GIT_UPDATE_ARGS}
		;;
		portsnap)
			[ -d "${BACKUPDIR}" ] && portsnap_soft_revert
			${PORTSNAP} ${PORTSNAP_ARGS} ${PORTSNAP_FETCH_ARGS} ${PORTSNAP_UPDATE_ARGS}
	esac
fi

add_patchfile() {
	case ${REPO_TYPE} in
	svn*)	PATCH_FILES_LIST="${PATCH_FILES_LIST}
"`echo "${OUTPUT}" | ${GREP} '^[^\>][ ][ ][ ].*' |  ${AWK} '{ print $(NF) }'` ;;
	git*)	PATCH_FILES_LIST="${PATCH_FILES_LIST} 
"`echo "${OUTPUT}" | ${GREP} '\.\.\.$' | ${AWK} '{ print $(NF) }'| ${SED} 's/\.\.\.$//'` ;;
	portsnap*)	PATCH_FILES_LIST="${PATCH_FILES_LIST}
"`${PATCH} ${PATCH_ARGS} -C -p${STRIP_COUNT} -d "${PORTSDIR}" -i "$1" | ${GREP} -A 2 '\-\-\-\-' | ${GREP} '\.\.\.$' | ${AWK} '{ print $3 }'` ;;
	esac
	PATCH_STRIP_COUNT="${PATCH_STRIP_COUNT}
${STRIP_COUNT}"
	STRIP_COUNT="$(( ${MAX_STRIP_COUNT} + 10 ))"
}

patchfile_check() {
HIGHEST_SUCCESS="0"
HIGHEST_FAILED="0"
cd ${PORTSDIR}
while [ "${MAX_STRIP_COUNT}" -ge "${STRIP_COUNT}" ]; do
	case ${REPO_TYPE} in
	svn*)	OUTPUT="`${SVN} ${SVN_PATCH_ARGS} --dry-run --strip ${STRIP_COUNT} "$1" ${PORTSDIR}`"
		SUCCESS="`echo "${OUTPUT}" | ${GREP} -co '^.[ ][ ][ ]*'`"
		FAILED="`echo "${OUTPUT}" | ${GREP} -co '^Skipped'`"
		[ "${STRIP_COUNT}" -eq "0" ] && [ "${FAILED}" -eq "0" ] && add_patchfile && return ;;
	git*)	OUTPUT="`${GIT} ${GIT_APPLY_ARGS} -p${STRIP_COUNT} --check -v "$1" 2>&1`"
		[ "$?" -eq "0" ] && add_patchfile && return
		[ "`echo "${OUTPUT}" | ${GREP} -com1 'patch does not apply'`" -ge "1" ] && add_patchfile && return
		SUCCESS="`echo "${OUTPUT}" | ${GREP} -co '\.\.\.$'`"
		FAILED="`echo "${OUTPUT}" | ${GREP} -co ':'`"
		SUCCESS="$(( ${SUCCESS} - ${FAILED} ))" ;;
	portsnap*)	OUTPUT="`${PATCH} ${PATCH_ARGS} -sC -p${STRIP_COUNT} -d "${PORTSDIR}" -i "$1"`"
			[ "$?" -eq "0" ] && add_patchfile "$1" && return
			SUCCESS="100000"
			FAILED="`echo "${OUTPUT}" | ${GREP} -co '\.\.\.'`" ;;
	esac
		[ "$(( ${HIGHEST_SUCCESS} - ${HIGHEST_FAILED} ))" -lt "$(( ${SUCCESS} - ${FAILED} ))" ] && HIGHEST_SUCCESS="${SUCCESS}" HIGHEST_FAILED="${FAILED}" HIGHEST_STRIP_COUNT="${STRIP_COUNT}" HIGHEST_OUTPUT="${OUTPUT}"
		STRIP_COUNT=$(( ${STRIP_COUNT} + 1 ))
		if [ "${MAX_STRIP_COUNT}" -eq "${STRIP_COUNT}" ]; then
			if [ "${HIGHEST_SUCCESS}" -gt "${HIGHEST_FAILED}" ]; then
				STRIP_COUNT="${HIGHEST_STRIP_COUNT}"
				OUTPUT="${HIGHEST_OUTPUT}"
				add_patchfile "$1" && return
			else
				echo Patchfile "$1" Failed, try a revert? && exit 1
			fi
		fi
done
}

patchfile_patch() {
for file in $1; do
	for pos in `echo $2 | ${AWK} "{ print ${DOLLARSIGN}${POS} }"`; do
		case ${REPO_TYPE} in
		svn*)	PATCH_OUTPUT="${PATCH_OUTPUT}
"`${SVN} ${SVN_PATCH_ARGS} ${SVN_CHECK_ARGS} --strip $pos "$file" "${PORTSDIR}" 2>&1` ;;
		git*)	PATCH_OUTPUT="${PATCH_OUTPUT}
"`${GIT} ${GIT_APPLY_ARGS} ${GIT_CHECK_ARGS} -p$pos "$file" 2>&1` ;;
		portsnap*)	PATCH_OUTPUT="${PATCH_OUTPUT}
"`${PATCH} ${PATCH_ARGS} ${PATCH_CHECK_ARGS} -s -p$pos -d "${PORTSDIR}" -i "$file" 2>&1` ;;
		esac
	done
	POS="$(( ${POS} + 1 ))"
done
}

filelist() {
case ${REPO_TYPE} in
	svn*);;
	git*);;
	*) check_command "${PATCH}" ;;
esac
for patchfile in ${UNI_PATCH_FILE}; do
	if [ "/dev/null" != "`${CAT} "$patchfile" | ${GREP} -m1 '^+++[ ]' | ${AWK} '{ print $2 }'`" ]; then
		MAX_STRIP_COUNT="`${CAT} "$patchfile" | ${GREP} -m1 '^+++[ ]' | ${AWK} '{ print $2 }'| ${AWK} -F/ '{ print NF-1 }'`"
		TRUE="1"
	else
		MAX_STRIP_COUNT="`${CAT} "$patchfile" | ${GREP} -m1 '^---[ ]' | ${AWK} '{ print $2 }'| ${AWK} -F/ '{ print NF-1 }'`"
		TRUE="0"
	fi
	case ${REPO_TYPE} in
		svn) STRIP_COUNT="0" ;;
		git) STRIP_COUNT="0" ;;
		*)	if [ "${TRUE}" -eq "1" ]; then
				STRIP_COUNT="`${CAT} "$patchfile" | ${GREP} -m1 '^+++[ ]' | ${AWK} '{ print $2 }' | ${GREP} -co '^/'`"
			else
				STRIP_COUNT="`${CAT} "$patchfile" | ${GREP} -m1 '^---[ ]' | ${AWK} '{ print $2 }' | ${GREP} -co '^/'`"
			fi;
	esac
	patchfile_check "$patchfile"
done
PATCH_FILES_LIST="`echo "${PATCH_FILES_LIST}" | ${SORT} -u`"
}

folderlist() {
[ -z "${PATCH_FILES_LIST}" ] && filelist
[ -n "${PATCH_FILES_LIST}" ] && PATCH_FOLDER_LIST="`echo "${PATCH_FILES_LIST}" | ${GREP} -o '^[^/]*\/[^/]*\/' | ${SED} 's/\/$//'`"
[ -n "${PATCH_FOLDER_LIST}" ] && PATCH_FOLDER_LIST="${PATCH_FOLDER_LIST}
"`echo "${PATCH_FILES_LIST}" | ${GREP} -o '^[^/]*\/[^/]*\/[^/]*\/' | ${SED} 's/\/$//'`
[ -n "${PATCH_FOLDER_LIST}" ] && PATCH_FOLDER_LIST="`echo "${PATCH_FOLDER_LIST}" | ${SORT} -u`"
}

### Patch Tree ###
if [ "${DO_PATCH}" -eq "1" ] || [ "${ALL}" -eq "1" ]; then
	[ -z "${PATCH_FOLDER_LIST}" ] && folderlist
	case ${REPO_TYPE} in
	portsnap*)	${MKDIR} -p ${BACKUPDIR} && cd ${BACKUPDIR}
			${MKDIR} -p `echo "${PATCH_FILES_LIST}" | ${SED} 's/^[A-Z].*//' | ${GREP} -o '^[^/]*\/[^/]*\/' | ${SED} 's/\/$// ; s/[^/]*$//' | ${SORT} -u`
			cd ${PORTSDIR}
			for dir in `${FIND} ./ -type d -maxdepth 1 | ${SED} 's/^\.\///' | ${GREP} '^[A-Z]'`; do
				! [ -d "${BACKUPDIR}/$dir" ] && cp -Ra "${PORTSDIR}/$dir" "${BACKUPDIR}/$dir"
			done
			for file in `${FIND} ./ -type f -maxdepth 2 | ${SED} 's/^\.\/// ; s/distfiles.*//'`; do
				! [ -f "${BACKUPDIR}/$file" ] && cp -a "${PORTSDIR}/$file" "${BACKUPDIR}/$file" >/dev/null 2>&1
			done
			for dir in `echo "${PATCH_FOLDER_LIST}"`; do
				! [ -d "${PORTSDIR}/$dir" ] && ${MKDIR} -p "${PORTSDIR}/$dir"
			done
			for dir in `echo "${PATCH_FILES_LIST}" | ${GREP} -o '^[^/]*\/[^/]*\/' | ${SED} 's/\/$//' | ${SORT} -u`; do
				! [ -d "${BACKUPDIR}/$dir" ] && cp -Ra "${PORTSDIR}/$dir" "${BACKUPDIR}/$dir"
			done ;;
	git*)		for dir in `echo "${PATCH_FOLDER_LIST}"`; do
				! [ -d "${PORTSDIR}/$dir" ] && ${MKDIR} -p "${PORTSDIR}/$dir"
			done
			for file in `echo "${PATCH_FILES_LIST}"`; do
				! [ -f "${PORTSDIR}/$file" ] && ${TOUCH} "${PORTSDIR}/$file"
			done ;;
	svn*)	;;
	esac
	DOLLARSIGN="$"
	POS="1"
	cd ${PORTSDIR}
	[ -n "${UNI_PATCH_FILE}" ] && patchfile_patch "${UNI_PATCH_FILE}" "${PATCH_STRIP_COUNT}"
	case ${REPO_TYPE} in
	svn*)	if [ "`echo "${PATCH_OUTPUT}" | ${GREP} -com1 reject`" -gt "0" ]; then
			echo "${PATCH_OUTPUT}" | ${GREP} '^[^ ].*'
			echo "Patch Failed"
			exit 1
		fi
		echo "${PATCH_OUTPUT}" | ${GREP} '^[^ ].*';;
	git*)	if [ "`echo "${PATCH_OUTPUT}" | ${GREP} -com1 error`" -gt "0" ]; then
			echo "${PATCH_OUTPUT}" | ${GREP} '^[^ ].*'
			echo "Patch Failed"
			exit 1
		fi
		echo "${PATCH_OUTPUT}" | ${GREP} '^[^ ].*'
		${GIT} ${GIT_ADD_ARGS} ${PATCH_FOLDER_LIST}
		${RM} `${FIND} ${PATCH_FOLDER_LIST} -maxdepth 1 -empty` 2>/dev/null ;;
	*)	if [ "`echo "${PATCH_OUTPUT}" | ${GREP} -com1 rejects`" -gt "0" ]; then
			echo "${PATCH_OUTPUT}" | ${GREP} '^[^ ].*'
			echo "Patch Failed"
			exit 1
		fi
		echo "${PATCH_OUTPUT}" | ${GREP} '^[^ ].*'
		cd ${PORTSDIR}
		${RM} `${FIND} ${PATCH_FOLDER_LIST} -maxdepth 1 -name "*.orig"` 2>/dev/null ;;
	esac
fi

# Generate a list of ports for poudriere to build #
buildlist() {
if [ "${REPO_BUILD_LIST}" -eq "1" ]; then
cd ${PORTSDIR}
BUILD_LIST="`${REPO} ${REPO_STATUS} | ${AWK} '{ print $(NF) }' | ${SED} 's/^[A-Z].*//' | ${GREP} -o '^[^/]*\/[^/]*\/' | ${SED} 's/\/$//' | ${SORT} -u`"
else
[ -z "${PATCH_FILES_LIST}" ] && filelist
BUILD_LIST="`echo "${PATCH_FILES_LIST}" | ${SED} 's/^[A-Z].*//' | ${GREP} -o '^[^/]*\/[^/]*\/' | ${SED} 's/\/$//' | ${SORT} -u`"
fi
}

### Bulk File ###
if [ "$POUDRIERE_BULK" -eq "1" ]; then
	[ -z "${BUILD_LIST}" ] && buildlist
	cd "${CURDIR}"
	echo "${BUILD_LIST}" >"${POUDRIERE_BULK_FILE}"
elif [ "${ALL}" -eq "1" ]; then
	[ -z "${BUILD_LIST}" ] && buildlist
	cd "${CURDIR}"
	echo "${BUILD_LIST}" >"${BULK_FILE}"
fi

### Portlint ###
if [ "${TEST_PORTLINT}" -eq "1" ] || [ "${ALL}" -eq "1" ]; then
	check_portlint
	[ -z "${BUILD_LIST}" ] && buildlist
	for port in ${BUILD_LIST}; do
		cd "${PORTSDIR}/$port"
		echo "$port"
		${PORTLINT} ${PORTLINT_ARGS}
	done
fi


### Port test and Poudriere testing ###
if [ "${TEST_BUILD}" -eq "1" ] && [ "${USE_POUDRIERE}" != "YES" ]; then
	check_port
	check_make
	${RM} -rf "`${FIND} ${PORTSDIR} -type d -name "work" -maxdepth 3`"
	[ -z "${BUILD_LIST}" ] && buildlist
	for port in ${BUILD_LIST}; do
		cd "${PORTSDIR}/$port"
		${MAKE} depends BATCH=yes
		${PORT} ${PORT_ARGS}
	done
elif [ "${TEST_BUILD}" -eq "1" ] && [ "${USE_POUDRIERE}" == "YES" ]; then
	check_tmux
	[ -z ${TMUX_SESSION} ] && check_openssl
	[ -z "${BUILD_LIST}" ] && buildlist
	: ${TMUX_SESSION:="portest-`${OPENSSL} rand -hex 16`"}
	printf "Verifying jails not already running"
	for jail in ${POUDRIERE_JAILS}; do
		if [ "`${POUDRIERE} ${POUDRIERE_STATUS_ARGS} -j $jail | ${AWK} '{ print $2 }' | ${GREP} -com1 "^${POUDRIERE_PORT}$"`" -eq "1" ]; then
			echo " $jail is already running on ${POUDRIERE_PORT}" && exit 1
		fi
		printf "."
	done
	printf " Done"
	printf "\nStarting jails"
	for jail in ${POUDRIERE_JAILS}; do
		if [ "`${TMUX_COMMAND} list-sessions | ${GREP} -com1 "${TMUX_SESSION}"`" -ne "1" ]; then
			${TMUX_COMMAND} new-session -ds "${TMUX_SESSION}" ${POUDRIERE} ${POUDRIERE_BULK_ARGS} -j $jail ${BUILD_LIST}
		else
			${TMUX_COMMAND} split-window -dt "${TMUX_SESSION}" ${POUDRIERE} ${POUDRIERE_BULK_ARGS} -j $jail ${BUILD_LIST}
		fi
		${SLEEP} 1
		printf "."
	done
	printf " Done"
	printf "\nVerifying jails started successfully... Please wait"
	: ${JAIL_MAX_VERIFY:="3"}
	JAIL_VERIFY="0"
	JAILS_STARTED="0"
	while [ ${JAILS_STARTED} -ne "1" ] && [ "${JAIL_MAX_VERIFY}" -ge "${JAIL_VERIFY}" ]; do
		${SLEEP} 10
		JAILS_STARTED="1"
		for jail in ${POUDRIERE_JAILS}; do
			OUTPUT="`${POUDRIERE} ${POUDRIERE_STATUS_ARGS} -j $jail | ${AWK} '{ print $2 }' | ${GREP} -com1 "^${POUDRIERE_PORT}$"`"
			if [ "${OUTPUT}" -ne "1" ]; then
				if [ "`${TMUX_COMMAND} list-sessions | ${GREP} -com1 "${TMUX_SESSION}"`" -eq "1" ]; then
					${TMUX_COMMAND} split-window -dt "${TMUX_SESSION}" ${POUDRIERE} ${POUDRIERE_BULK_ARGS} -j $jail ${BUILD_LIST}
				else
					${TMUX_COMMAND} new-session -ds "${TMUX_SESSION}" ${POUDRIERE} ${POUDRIERE_BULK_ARGS} -j $jail ${BUILD_LIST}
				fi
			fi
			if [ "${JAILS_STARTED}" -ne "0" ] && [ "${OUTPUT}" -eq "1" ] ; then
				JAILS_STARTED="1"
			else
				JAILS_STARTED="0"
			fi
			printf "."
		done
		JAIL_VERIFY=$(( ${JAIL_VERIFY} + 1 ))
	done
	printf " done"
	${TMUX_COMMAND} select-layout -t "${TMUX_SESSION}" ${TMUX_LAYOUT}
	${TMUX_COMMAND} attach-session -t "${TMUX_SESSION}" >/dev/null 2>&1
	if [ "$?" -ne 0 ]; then
		${TMUX_COMMAND} switch -t "${TMUX_SESSION}"
	fi
	if [ "${REVERT_SOFT}" -eq "1" ] || [ "${REVERT_HARD}" -eq "1" ]; then
		while [ "`${TMUX_COMMAND} list-sessions -F \#S | ${GREP} -com1 "${TMUX_SESSION}"`" -eq "1" ]; do
			${SLEEP} 10
		done
	fi
fi

### Revert Patch ###
cd ${PORTSDIR}
case ${REPO_TYPE} in
	svn*)	if [ "${REVERT_SOFT}" -eq "1" ] && [ "${REVERT_HARD}" -ne "1" ]; then
			[ -z "${BUILD_LIST}" ] && buildlist
# Wierd cases where svn won't see short filenames in list.    #
# This seems to be an svn bug, this list helps in those cases #
			PATCH_FILES_FILTERED="`echo "${PATCH_FILES_LIST}" | ${GREP} -v '^[^/]*\/[^/]*\/[^/]*'`"
			for file in ${BUILD_LIST}; do
				${RM} -rf "${PORTSDIR}/$file"
			done
			for file in ${PATCH_FILES_LIST}; do
				${RM} -rf "${PORTSDIR}/$file"
			done
			[ -n "${BUILD_LIST}" ] && ${SVN} ${SVN_REVERT_ARGS} ${BUILD_LIST}
			[ -n "${PATCH_FILES_LIST}" ] && ${SVN} ${SVN_REVERT_ARGS} ${PATCH_FILES_LIST}
			[ -n "${PATCH_FILES_FILTERED}" ] && ${SVN} ${SVN_REVERT_ARGS} ${PATCH_FILES_FILTERED}
			${RM} `${FIND} ./ -maxdepth 1 -name "*.[ro][er][ji]*"` >/dev/null 2>&1
		elif [ "${REVERT_HARD}"  -eq "1" ]; then
			svn_hard_revert
		fi ;;
	git*)	if [ "${REVERT_SOFT}" -eq "1" ] || [ "${REVERT_HARD}" -eq "1" ]; then
			git_revert
		fi ;;
	portsnap*)	if [ "${REVERT_SOFT}" -eq "1" ] && [ "${REVERT_HARD}" -ne "1" ]; then
				! [ -d "${BACKUPDIR}" ] && echo "Nothing to revert, try the -R option?" && exit 1
				portsnap_soft_revert
			elif [ "${REVERT_HARD}"  -eq "1" ]; then
				${PORTSNAP} ${PORTSNAP_ARGS} ${PORTSNAP_EXTRACT_ARGS}
				cd ${PORTSDIR}
				${RM} -rf "${BACKUPDIR}"
				${RM} `${FIND} ./ -maxdepth 1 -name "*.[ro][er][ji]*"` >/dev/null 2>&1
			fi ;;
esac
